{"/home/travis/build/npmtest/node-npmtest-jison/test.js":"/* istanbul instrument in package npmtest_jison */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jison/lib.npmtest_jison.js":"/* istanbul instrument in package npmtest_jison */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jison = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jison = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jison/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jison && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jison */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jison\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jison.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jison.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jison.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jison.__dirname + '/lib.npmtest_jison.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison/lib/jison.js":"// Jison, an LR(0), SLR(1), LARL(1), LR(1) Parser Generator\n// Zachary Carter <zach@carter.name>\n// MIT X Licensed\n\nvar typal      = require('./util/typal').typal;\nvar Set        = require('./util/set').Set;\nvar Lexer      = require('jison-lex');\nvar ebnfParser = require('ebnf-parser');\nvar JSONSelect = require('JSONSelect');\nvar esprima    = require('esprima');\nvar escodegen  = require('escodegen');\n\n\nvar version = require('../package.json').version;\n\nvar Jison = exports.Jison = exports;\nJison.version = version;\n\n// detect print\nif (typeof console !== 'undefined' && console.log) {\n    Jison.print = console.log;\n} else if (typeof puts !== 'undefined') {\n    Jison.print = function print () { puts([].join.call(arguments, ' ')); };\n} else if (typeof print !== 'undefined') {\n    Jison.print = print;\n} else {\n    Jison.print = function print () {};\n}\n\nJison.Parser = (function () {\n\n// iterator utility\nfunction each (obj, func) {\n    if (obj.forEach) {\n        obj.forEach(func);\n    } else {\n        var p;\n        for (p in obj) {\n            if (obj.hasOwnProperty(p)) {\n                func.call(obj, obj[p], p, obj);\n            }\n        }\n    }\n}\n\nvar Nonterminal = typal.construct({\n    constructor: function Nonterminal (symbol) {\n        this.symbol = symbol;\n        this.productions = new Set();\n        this.first = [];\n        this.follows = [];\n        this.nullable = false;\n    },\n    toString: function Nonterminal_toString () {\n        var str = this.symbol+\"\\n\";\n        str += (this.nullable ? 'nullable' : 'not nullable');\n        str += \"\\nFirsts: \"+this.first.join(', ');\n        str += \"\\nFollows: \"+this.first.join(', ');\n        str += \"\\nProductions:\\n  \"+this.productions.join('\\n  ');\n\n        return str;\n    }\n});\n\nvar Production = typal.construct({\n    constructor: function Production (symbol, handle, id) {\n        this.symbol = symbol;\n        this.handle = handle;\n        this.nullable = false;\n        this.id = id;\n        this.first = [];\n        this.precedence = 0;\n    },\n    toString: function Production_toString () {\n        return this.symbol+\" -> \"+this.handle.join(' ');\n    }\n});\n\nvar generator = typal.beget();\n\ngenerator.constructor = function Jison_Generator (grammar, opt) {\n    if (typeof grammar === 'string') {\n        grammar = ebnfParser.parse(grammar);\n    }\n\n    var options = typal.mix.call({}, grammar.options, opt);\n    this.terms = {};\n    this.operators = {};\n    this.productions = [];\n    this.conflicts = 0;\n    this.resolutions = [];\n    this.options = options;\n    this.parseParams = grammar.parseParams;\n    this.yy = {}; // accessed as yy free variable in the parser/lexer actions\n\n    // source included in semantic action execution scope\n    if (grammar.actionInclude) {\n        if (typeof grammar.actionInclude === 'function') {\n            grammar.actionInclude = String(grammar.actionInclude).replace(/^\\s*function \\(\\) \\{/, '').replace(/\\}\\s*$/, '');\n        }\n        this.actionInclude = grammar.actionInclude;\n    }\n    this.moduleInclude = grammar.moduleInclude || '';\n\n    this.DEBUG = options.debug || false;\n    if (this.DEBUG) this.mix(generatorDebug); // mixin debug methods\n\n    this.processGrammar(grammar);\n\n    if (grammar.lex) {\n        this.lexer = new Lexer(grammar.lex, null, this.terminals_);\n    }\n};\n\ngenerator.processGrammar = function processGrammarDef (grammar) {\n    var bnf = grammar.bnf,\n        tokens = grammar.tokens,\n        nonterminals = this.nonterminals = {},\n        productions = this.productions,\n        self = this;\n\n    if (!grammar.bnf && grammar.ebnf) {\n        bnf = grammar.bnf = ebnfParser.transform(grammar.ebnf);\n    }\n\n    if (tokens) {\n        if (typeof tokens === 'string') {\n            tokens = tokens.trim().split(' ');\n        } else {\n            tokens = tokens.slice(0);\n        }\n    }\n\n    var symbols = this.symbols = [];\n\n    // calculate precedence of operators\n    var operators = this.operators = processOperators(grammar.operators);\n\n    // build productions from cfg\n    this.buildProductions(bnf, productions, nonterminals, symbols, operators);\n\n    if (tokens && this.terminals.length !== tokens.length) {\n        self.trace(\"Warning: declared tokens differ from tokens found in rules.\");\n        self.trace(this.terminals);\n        self.trace(tokens);\n    }\n\n    // augment the grammar\n    this.augmentGrammar(grammar);\n};\n\ngenerator.augmentGrammar = function augmentGrammar (grammar) {\n    if (this.productions.length === 0) {\n        throw new Error(\"Grammar error: must have at least one rule.\");\n    }\n    // use specified start symbol, or default to first user defined production\n    this.startSymbol = grammar.start || grammar.startSymbol || this.productions[0].symbol;\n    if (!this.nonterminals[this.startSymbol]) {\n        throw new Error(\"Grammar error: startSymbol must be a non-terminal found in your grammar.\");\n    }\n    this.EOF = \"$end\";\n\n    // augment the grammar\n    var acceptProduction = new Production('$accept', [this.startSymbol, '$end'], 0);\n    this.productions.unshift(acceptProduction);\n\n    // prepend parser tokens\n    this.symbols.unshift(\"$accept\",this.EOF);\n    this.symbols_.$accept = 0;\n    this.symbols_[this.EOF] = 1;\n    this.terminals.unshift(this.EOF);\n\n    this.nonterminals.$accept = new Nonterminal(\"$accept\");\n    this.nonterminals.$accept.productions.push(acceptProduction);\n\n    // add follow $ to start symbol\n    this.nonterminals[this.startSymbol].follows.push(this.EOF);\n};\n\n// set precedence and associativity of operators\nfunction processOperators (ops) {\n    if (!ops) return {};\n    var operators = {};\n    for (var i=0,k,prec;prec=ops[i]; i++) {\n        for (k=1;k < prec.length;k++) {\n            operators[prec[k]] = {precedence: i+1, assoc: prec[0]};\n        }\n    }\n    return operators;\n}\n\n\ngenerator.buildProductions = function buildProductions(bnf, productions, nonterminals, symbols, operators) {\n    var actions = [\n      '/* this == yyval */',\n      this.actionInclude || '',\n      'var $0 = $$.length - 1;',\n      'switch (yystate) {'\n    ];\n    var actionGroups = {};\n    var prods, symbol;\n    var productions_ = [0];\n    var symbolId = 1;\n    var symbols_ = {};\n\n    var her = false; // has error recovery\n\n    function addSymbol (s) {\n        if (s && !symbols_[s]) {\n            symbols_[s] = ++symbolId;\n            symbols.push(s);\n        }\n    }\n\n    // add error symbol; will be third symbol, or \"2\" ($accept, $end, error)\n    addSymbol(\"error\");\n\n    for (symbol in bnf) {\n        if (!bnf.hasOwnProperty(symbol)) continue;\n\n        addSymbol(symbol);\n        nonterminals[symbol] = new Nonterminal(symbol);\n\n        if (typeof bnf[symbol] === 'string') {\n            prods = bnf[symbol].split(/\\s*\\|\\s*/g);\n        } else {\n            prods = bnf[symbol].slice(0);\n        }\n\n        prods.forEach(buildProduction);\n    }\n    for (var action in actionGroups)\n      actions.push(actionGroups[action].join(' '), action, 'break;');\n\n    var sym, terms = [], terms_ = {};\n    each(symbols_, function (id, sym) {\n        if (!nonterminals[sym]) {\n            terms.push(sym);\n            terms_[id] = sym;\n        }\n    });\n\n    this.hasErrorRecovery = her;\n\n    this.terminals = terms;\n    this.terminals_ = terms_;\n    this.symbols_ = symbols_;\n\n    this.productions_ = productions_;\n    actions.push('}');\n\n    actions = actions.join(\"\\n\")\n                .replace(/YYABORT/g, 'return false')\n                .replace(/YYACCEPT/g, 'return true');\n\n    var parameters = \"yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */\";\n    if (this.parseParams) parameters += ', ' + this.parseParams.join(', ');\n\n    this.performAction = \"function anonymous(\" + parameters + \") {\\n\" + actions + \"\\n}\";\n\n    function buildProduction (handle) {\n        var r, rhs, i;\n        if (handle.constructor === Array) {\n            rhs = (typeof handle[0] === 'string') ?\n                      handle[0].trim().split(' ') :\n                      handle[0].slice(0);\n\n            for (i=0; i<rhs.length; i++) {\n                if (rhs[i] === 'error') her = true;\n                if (!symbols_[rhs[i]]) {\n                    addSymbol(rhs[i]);\n                }\n            }\n\n            if (typeof handle[1] === 'string' || handle.length == 3) {\n                // semantic action specified\n                var label = 'case ' + (productions.length+1) + ':', action = handle[1];\n\n                // replace named semantic values ($nonterminal)\n                if (action.match(/[$@][a-zA-Z][a-zA-Z0-9_]*/)) {\n                    var count = {},\n                        names = {};\n                    for (i=0;i<rhs.length;i++) {\n                        // check for aliased names, e.g., id[alias]\n                        var rhs_i = rhs[i].match(/\\[[a-zA-Z][a-zA-Z0-9_-]*\\]/);\n                        if (rhs_i) {\n                            rhs_i = rhs_i[0].substr(1, rhs_i[0].length-2);\n                            rhs[i] = rhs[i].substr(0, rhs[i].indexOf('['));\n                        } else {\n                            rhs_i = rhs[i];\n                        }\n\n                        if (names[rhs_i]) {\n                            names[rhs_i + (++count[rhs_i])] = i+1;\n                        } else {\n                            names[rhs_i] = i+1;\n                            names[rhs_i + \"1\"] = i+1;\n                            count[rhs_i] = 1;\n                        }\n                    }\n                    action = action.replace(/\\$([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {\n                            return names[pl] ? '$'+names[pl] : str;\n                        }).replace(/@([a-zA-Z][a-zA-Z0-9_]*)/g, function (str, pl) {\n                            return names[pl] ? '@'+names[pl] : str;\n                        });\n                }\n                action = action\n                    // replace references to $$ with this.$, and @$ with this._$\n                    .replace(/([^'\"])\\$\\$|^\\$\\$/g, '$1this.$').replace(/@[0$]/g, \"this._$\")\n\n                    // replace semantic value references ($n) with stack value (stack[n])\n                    .replace(/\\$(-?\\d+)/g, function (_, n) {\n                        return \"$$[$0\" + (parseInt(n, 10) - rhs.length || '') + \"]\";\n                    })\n                    // same as above for location references (@n)\n                    .replace(/@(-?\\d+)/g, function (_, n) {\n                        return \"_$[$0\" + (n - rhs.length || '') + \"]\";\n                    });\n                if (action in actionGroups) actionGroups[action].push(label);\n                else actionGroups[action] = [label];\n\n                // done with aliases; strip them.\n                rhs = rhs.map(function(e,i) { return e.replace(/\\[[a-zA-Z_][a-zA-Z0-9_-]*\\]/g, '') });\n                r = new Production(symbol, rhs, productions.length+1);\n                // precedence specified also\n                if (handle[2] && operators[handle[2].prec]) {\n                    r.precedence = operators[handle[2].prec].precedence;\n                }\n            } else {\n                // no action -> don't care about aliases; strip them.\n                rhs = rhs.map(function(e,i) { return e.replace(/\\[[a-zA-Z_][a-zA-Z0-9_-]*\\]/g, '') });\n                // only precedence specified\n                r = new Production(symbol, rhs, productions.length+1);\n                if (operators[handle[1].prec]) {\n                    r.precedence = operators[handle[1].prec].precedence;\n                }\n            }\n        } else {\n            // no action -> don't care about aliases; strip them.\n            handle = handle.replace(/\\[[a-zA-Z_][a-zA-Z0-9_-]*\\]/g, '');\n            rhs = handle.trim().split(' ');\n            for (i=0; i<rhs.length; i++) {\n                if (rhs[i] === 'error') her = true;\n                if (!symbols_[rhs[i]]) {\n                    addSymbol(rhs[i]);\n                }\n            }\n            r = new Production(symbol, rhs, productions.length+1);\n        }\n        if (r.precedence === 0) {\n            // set precedence\n            for (i=r.handle.length-1; i>=0; i--) {\n                if (!(r.handle[i] in nonterminals) && r.handle[i] in operators) {\n                    r.precedence = operators[r.handle[i]].precedence;\n                }\n            }\n        }\n\n        productions.push(r);\n        productions_.push([symbols_[r.symbol], r.handle[0] === '' ? 0 : r.handle.length]);\n        nonterminals[symbol].productions.push(r);\n    }\n};\n\n\n\ngenerator.createParser = function createParser () {\n    throw new Error('Calling abstract method.');\n};\n\n// noop. implemented in debug mixin\ngenerator.trace = function trace () { };\n\ngenerator.warn = function warn () {\n    var args = Array.prototype.slice.call(arguments,0);\n    Jison.print.call(null,args.join(\"\"));\n};\n\ngenerator.error = function error (msg) {\n    throw new Error(msg);\n};\n\n// Generator debug mixin\n\nvar generatorDebug = {\n    trace: function trace () {\n        Jison.print.apply(null, arguments);\n    },\n    beforeprocessGrammar: function () {\n        this.trace(\"Processing grammar.\");\n    },\n    afteraugmentGrammar: function () {\n        var trace = this.trace;\n        each(this.symbols, function (sym, i) {\n            trace(sym+\"(\"+i+\")\");\n        });\n    }\n};\n\n\n\n/*\n * Mixin for common behaviors of lookahead parsers\n * */\nvar lookaheadMixin = {};\n\nlookaheadMixin.computeLookaheads = function computeLookaheads () {\n    if (this.DEBUG) this.mix(lookaheadDebug); // mixin debug methods\n\n    this.computeLookaheads = function () {};\n    this.nullableSets();\n    this.firstSets();\n    this.followSets();\n};\n\n// calculate follow sets typald on first and nullable\nlookaheadMixin.followSets = function followSets () {\n    var productions = this.productions,\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true;\n\n    // loop until no further changes have been made\n    while(cont) {\n        cont = false;\n\n        productions.forEach(function Follow_prod_forEach (production, k) {\n            //self.trace(production.symbol,nonterminals[production.symbol].follows);\n            // q is used in Simple LALR algorithm determine follows in context\n            var q;\n            var ctx = !!self.go_;\n\n            var set = [],oldcount;\n            for (var i=0,t;t=production.handle[i];++i) {\n                if (!nonterminals[t]) continue;\n\n                // for Simple LALR algorithm, self.go_ checks if\n                if (ctx)\n                    q = self.go_(production.symbol, production.handle.slice(0, i));\n                var bool = !ctx || q === parseInt(self.nterms_[t], 10);\n\n                if (i === production.handle.length+1 && bool) {\n                    set = nonterminals[production.symbol].follows;\n                } else {\n                    var part = production.handle.slice(i+1);\n\n                    set = self.first(part);\n                    if (self.nullable(part) && bool) {\n                        set.push.apply(set, nonterminals[production.symbol].follows);\n                    }\n                }\n                oldcount = nonterminals[t].follows.length;\n                Set.union(nonterminals[t].follows, set);\n                if (oldcount !== nonterminals[t].follows.length) {\n                    cont = true;\n                }\n            }\n        });\n    }\n};\n\n// return the FIRST set of a symbol or series of symbols\nlookaheadMixin.first = function first (symbol) {\n    // epsilon\n    if (symbol === '') {\n        return [];\n    // RHS\n    } else if (symbol instanceof Array) {\n        var firsts = [];\n        for (var i=0,t;t=symbol[i];++i) {\n            if (!this.nonterminals[t]) {\n                if (firsts.indexOf(t) === -1)\n                    firsts.push(t);\n            } else {\n                Set.union(firsts, this.nonterminals[t].first);\n            }\n            if (!this.nullable(t))\n                break;\n        }\n        return firsts;\n    // terminal\n    } else if (!this.nonterminals[symbol]) {\n        return [symbol];\n    // nonterminal\n    } else {\n        return this.nonterminals[symbol].first;\n    }\n};\n\n// fixed-point calculation of FIRST sets\nlookaheadMixin.firstSets = function firstSets () {\n    var productions = this.productions,\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true,\n        symbol,firsts;\n\n    // loop until no further changes have been made\n    while(cont) {\n        cont = false;\n\n        productions.forEach(function FirstSets_forEach (production, k) {\n            var firsts = self.first(production.handle);\n            if (firsts.length !== production.first.length) {\n                production.first = firsts;\n                cont=true;\n            }\n        });\n\n        for (symbol in nonterminals) {\n            firsts = [];\n            nonterminals[symbol].productions.forEach(function (production) {\n                Set.union(firsts, production.first);\n            });\n            if (firsts.length !== nonterminals[symbol].first.length) {\n                nonterminals[symbol].first = firsts;\n                cont=true;\n            }\n        }\n    }\n};\n\n// fixed-point calculation of NULLABLE\nlookaheadMixin.nullableSets = function nullableSets () {\n    var firsts = this.firsts = {},\n        nonterminals = this.nonterminals,\n        self = this,\n        cont = true;\n\n    // loop until no further changes have been made\n    while(cont) {\n        cont = false;\n\n        // check if each production is nullable\n        this.productions.forEach(function (production, k) {\n            if (!production.nullable) {\n                for (var i=0,n=0,t;t=production.handle[i];++i) {\n                    if (self.nullable(t)) n++;\n                }\n                if (n===i) { // production is nullable if all tokens are nullable\n                    production.nullable = cont = true;\n                }\n            }\n        });\n\n        //check if each symbol is nullable\n        for (var symbol in nonterminals) {\n            if (!this.nullable(symbol)) {\n                for (var i=0,production;production=nonterminals[symbol].productions.item(i);i++) {\n                    if (production.nullable)\n                        nonterminals[symbol].nullable = cont = true;\n                }\n            }\n        }\n    }\n};\n\n// check if a token or series of tokens is nullable\nlookaheadMixin.nullable = function nullable (symbol) {\n    // epsilon\n    if (symbol === '') {\n        return true;\n    // RHS\n    } else if (symbol instanceof Array) {\n        for (var i=0,t;t=symbol[i];++i) {\n            if (!this.nullable(t))\n                return false;\n        }\n        return true;\n    // terminal\n    } else if (!this.nonterminals[symbol]) {\n        return false;\n    // nonterminal\n    } else {\n        return this.nonterminals[symbol].nullable;\n    }\n};\n\n\n// lookahead debug mixin\nvar lookaheadDebug = {\n    beforenullableSets: function () {\n        this.trace(\"Computing Nullable sets.\");\n    },\n    beforefirstSets: function () {\n        this.trace(\"Computing First sets.\");\n    },\n    beforefollowSets: function () {\n        this.trace(\"Computing Follow sets.\");\n    },\n    afterfollowSets: function () {\n        var trace = this.trace;\n        each(this.nonterminals, function (nt, t) {\n            trace(nt, '\\n');\n        });\n    }\n};\n\n/*\n * Mixin for common LR parser behavior\n * */\nvar lrGeneratorMixin = {};\n\nlrGeneratorMixin.buildTable = function buildTable () {\n    if (this.DEBUG) this.mix(lrGeneratorDebug); // mixin debug methods\n\n    this.states = this.canonicalCollection();\n    this.table = this.parseTable(this.states);\n    this.defaultActions = findDefaults(this.table);\n};\n\nlrGeneratorMixin.Item = typal.construct({\n    constructor: function Item(production, dot, f, predecessor) {\n        this.production = production;\n        this.dotPosition = dot || 0;\n        this.follows = f || [];\n        this.predecessor = predecessor;\n        this.id = parseInt(production.id+'a'+this.dotPosition, 36);\n        this.markedSymbol = this.production.handle[this.dotPosition];\n    },\n    remainingHandle: function () {\n        return this.production.handle.slice(this.dotPosition+1);\n    },\n    eq: function (e) {\n        return e.id === this.id;\n    },\n    handleToString: function () {\n        var handle = this.production.handle.slice(0);\n        handle[this.dotPosition] = '.'+(handle[this.dotPosition]||'');\n        return handle.join(' ');\n    },\n    toString: function () {\n        var temp = this.production.handle.slice(0);\n        temp[this.dotPosition] = '.'+(temp[this.dotPosition]||'');\n        return this.production.symbol+\" -> \"+temp.join(' ') +\n            (this.follows.length === 0 ? \"\" : \" #lookaheads= \"+this.follows.join(' '));\n    }\n});\n\nlrGeneratorMixin.ItemSet = Set.prototype.construct({\n    afterconstructor: function () {\n        this.reductions = [];\n        this.goes = {};\n        this.edges = {};\n        this.shifts = false;\n        this.inadequate = false;\n        this.hash_ = {};\n        for (var i=this._items.length-1;i >=0;i--) {\n            this.hash_[this._items[i].id] = true; //i;\n        }\n    },\n    concat: function concat (set) {\n        var a = set._items || set;\n        for (var i=a.length-1;i >=0;i--) {\n            this.hash_[a[i].id] = true; //i;\n        }\n        this._items.push.apply(this._items, a);\n        return this;\n    },\n    push: function (item) {\n        this.hash_[item.id] = true;\n        return this._items.push(item);\n    },\n    contains: function (item) {\n        return this.hash_[item.id];\n    },\n    valueOf: function toValue () {\n        var v = this._items.map(function (a) {return a.id;}).sort().join('|');\n        this.valueOf = function toValue_inner() {return v;};\n        return v;\n    }\n});\n\nlrGeneratorMixin.closureOperation = function closureOperation (itemSet /*, closureSet*/) {\n    var closureSet = new this.ItemSet();\n    var self = this;\n\n    var set = itemSet,\n        itemQueue, syms = {};\n\n    do {\n    itemQueue = new Set();\n    closureSet.concat(set);\n    set.forEach(function CO_set_forEach (item) {\n        var symbol = item.markedSymbol;\n\n        // if token is a non-terminal, recursively add closures\n        if (symbol && self.nonterminals[symbol]) {\n            if(!syms[symbol]) {\n                self.nonterminals[symbol].productions.forEach(function CO_nt_forEach (production) {\n                    var newItem = new self.Item(production, 0);\n                    if(!closureSet.contains(newItem))\n                        itemQueue.push(newItem);\n                });\n                syms[symbol] = true;\n            }\n        } else if (!symbol) {\n            // reduction\n            closureSet.reductions.push(item);\n            closureSet.inadequate = closureSet.reductions.length > 1 || closureSet.shifts;\n        } else {\n            // shift\n            closureSet.shifts = true;\n            closureSet.inadequate = closureSet.reductions.length > 0;\n        }\n    });\n\n    set = itemQueue;\n\n    } while (!itemQueue.isEmpty());\n\n    return closureSet;\n};\n\nlrGeneratorMixin.gotoOperation = function gotoOperation (itemSet, symbol) {\n    var gotoSet = new this.ItemSet(),\n        self = this;\n\n    itemSet.forEach(function goto_forEach(item, n) {\n        if (item.markedSymbol === symbol) {\n            gotoSet.push(new self.Item(item.production, item.dotPosition+1, item.follows, n));\n        }\n    });\n\n    return gotoSet.isEmpty() ? gotoSet : this.closureOperation(gotoSet);\n};\n\n/* Create unique set of item sets\n * */\nlrGeneratorMixin.canonicalCollection = function canonicalCollection () {\n    var item1 = new this.Item(this.productions[0], 0, [this.EOF]);\n    var firstState = this.closureOperation(new this.ItemSet(item1)),\n        states = new Set(firstState),\n        marked = 0,\n        self = this,\n        itemSet;\n\n    states.has = {};\n    states.has[firstState] = 0;\n\n    while (marked !== states.size()) {\n        itemSet = states.item(marked); marked++;\n        itemSet.forEach(function CC_itemSet_forEach (item) {\n            if (item.markedSymbol && item.markedSymbol !== self.EOF)\n                self.canonicalCollectionInsert(item.markedSymbol, itemSet, states, marked-1);\n        });\n    }\n\n    return states;\n};\n\n// Pushes a unique state into the que. Some parsing algorithms may perform additional operations\nlrGeneratorMixin.canonicalCollectionInsert = function canonicalCollectionInsert (symbol, itemSet, states, stateNum) {\n    var g = this.gotoOperation(itemSet, symbol);\n    if (!g.predecessors)\n        g.predecessors = {};\n    // add g to que if not empty or duplicate\n    if (!g.isEmpty()) {\n        var gv = g.valueOf(),\n            i = states.has[gv];\n        if (i === -1 || typeof i === 'undefined') {\n            states.has[gv] = states.size();\n            itemSet.edges[symbol] = states.size(); // store goto transition for table\n            states.push(g);\n            g.predecessors[symbol] = [stateNum];\n        } else {\n            itemSet.edges[symbol] = i; // store goto transition for table\n            states.item(i).predecessors[symbol].push(stateNum);\n        }\n    }\n};\n\nvar NONASSOC = 0;\nlrGeneratorMixin.parseTable = function parseTable (itemSets) {\n    var states = [],\n        nonterminals = this.nonterminals,\n        operators = this.operators,\n        conflictedStates = {}, // array of [state, token] tuples\n        self = this,\n        s = 1, // shift\n        r = 2, // reduce\n        a = 3; // accept\n\n    // for each item set\n    itemSets.forEach(function (itemSet, k) {\n        var state = states[k] = {};\n        var action, stackSymbol;\n\n        // set shift and goto actions\n        for (stackSymbol in itemSet.edges) {\n            itemSet.forEach(function (item, j) {\n                // find shift and goto actions\n                if (item.markedSymbol == stackSymbol) {\n                    var gotoState = itemSet.edges[stackSymbol];\n                    if (nonterminals[stackSymbol]) {\n                        // store state to go to after a reduce\n                        //self.trace(k, stackSymbol, 'g'+gotoState);\n                        state[self.symbols_[stackSymbol]] = gotoState;\n                    } else {\n                        //self.trace(k, stackSymbol, 's'+gotoState);\n                        state[self.symbols_[stackSymbol]] = [s,gotoState];\n                    }\n                }\n            });\n        }\n\n        // set accept action\n        itemSet.forEach(function (item, j) {\n            if (item.markedSymbol == self.EOF) {\n                // accept\n                state[self.symbols_[self.EOF]] = [a];\n                //self.trace(k, self.EOF, state[self.EOF]);\n            }\n        });\n\n        var allterms = self.lookAheads ? false : self.terminals;\n\n        // set reductions and resolve potential conflicts\n        itemSet.reductions.forEach(function (item, j) {\n            // if parser uses lookahead, only enumerate those terminals\n            var terminals = allterms || self.lookAheads(itemSet, item);\n\n            terminals.forEach(function (stackSymbol) {\n                action = state[self.symbols_[stackSymbol]];\n                var op = operators[stackSymbol];\n\n                // Reading a terminal and current position is at the end of a production, try to reduce\n                if (action || action && action.length) {\n                    var sol = resolveConflict(item.production, op, [r,item.production.id], action[0] instanceof Array ? action[0] : action);\n                    self.resolutions.push([k,stackSymbol,sol]);\n                    if (sol.bydefault) {\n                        self.conflicts++;\n                        if (!self.DEBUG) {\n                            self.warn('Conflict in grammar: multiple actions possible when lookahead token is ',stackSymbol,' in state ',k, \"\\n- \", printAction(sol.r, self), \"\\n- \", printAction(sol.s, self));\n                            conflictedStates[k] = true;\n                        }\n                        if (self.options.noDefaultResolve) {\n                            if (!(action[0] instanceof Array))\n                                action = [action];\n                            action.push(sol.r);\n                        }\n                    } else {\n                        action = sol.action;\n                    }\n                } else {\n                    action = [r,item.production.id];\n                }\n                if (action && action.length) {\n                    state[self.symbols_[stackSymbol]] = action;\n                } else if (action === NONASSOC) {\n                    state[self.symbols_[stackSymbol]] = undefined;\n                }\n            });\n        });\n\n    });\n\n    if (!self.DEBUG && self.conflicts > 0) {\n        self.warn(\"\\nStates with conflicts:\");\n        each(conflictedStates, function (val, state) {\n            self.warn('State '+state);\n            self.warn('  ',itemSets.item(state).join(\"\\n  \"));\n        });\n    }\n\n    return states;\n};\n\n// find states with only one action, a reduction\nfunction findDefaults (states) {\n    var defaults = {};\n    states.forEach(function (state, k) {\n        var i = 0;\n        for (var act in state) {\n             if ({}.hasOwnProperty.call(state, act)) i++;\n        }\n\n        if (i === 1 && state[act][0] === 2) {\n            // only one action in state and it's a reduction\n            defaults[k] = state[act];\n        }\n    });\n\n    return defaults;\n}\n\n// resolves shift-reduce and reduce-reduce conflicts\nfunction resolveConflict (production, op, reduce, shift) {\n    var sln = {production: production, operator: op, r: reduce, s: shift},\n        s = 1, // shift\n        r = 2, // reduce\n        a = 3; // accept\n\n    if (shift[0] === r) {\n        sln.msg = \"Resolve R/R conflict (use first production declared in grammar.)\";\n        sln.action = shift[1] < reduce[1] ? shift : reduce;\n        if (shift[1] !== reduce[1]) sln.bydefault = true;\n        return sln;\n    }\n\n    if (production.precedence === 0 || !op) {\n        sln.msg = \"Resolve S/R conflict (shift by default.)\";\n        sln.bydefault = true;\n        sln.action = shift;\n    } else if (production.precedence < op.precedence ) {\n        sln.msg = \"Resolve S/R conflict (shift for higher precedent operator.)\";\n        sln.action = shift;\n    } else if (production.precedence === op.precedence) {\n        if (op.assoc === \"right\" ) {\n            sln.msg = \"Resolve S/R conflict (shift for right associative operator.)\";\n            sln.action = shift;\n        } else if (op.assoc === \"left\" ) {\n            sln.msg = \"Resolve S/R conflict (reduce for left associative operator.)\";\n            sln.action = reduce;\n        } else if (op.assoc === \"nonassoc\" ) {\n            sln.msg = \"Resolve S/R conflict (no action for non-associative operator.)\";\n            sln.action = NONASSOC;\n        }\n    } else {\n        sln.msg = \"Resolve conflict (reduce for higher precedent production.)\";\n        sln.action = reduce;\n    }\n\n    return sln;\n}\n\nlrGeneratorMixin.generate = function parser_generate (opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var code = \"\";\n\n    // check for illegal identifier\n    if (!opt.moduleName || !opt.moduleName.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/)) {\n        opt.moduleName = \"parser\";\n    }\n    switch (opt.moduleType) {\n        case \"js\":\n            code = this.generateModule(opt);\n            break;\n        case \"amd\":\n            code = this.generateAMDModule(opt);\n            break;\n        default:\n            code = this.generateCommonJSModule(opt);\n            break;\n    }\n\n    return code;\n};\n\nlrGeneratorMixin.generateAMDModule = function generateAMDModule(opt){\n    opt = typal.mix.call({}, this.options, opt);\n    var module = this.generateModule_();\n    var out = '\\n\\ndefine(function(require){\\n'\n        + module.commonCode\n        + '\\nvar parser = '+ module.moduleCode\n        + \"\\n\"+this.moduleInclude\n        + (this.lexer && this.lexer.generateModule ?\n          '\\n' + this.lexer.generateModule() +\n          '\\nparser.lexer = lexer;' : '')\n        + '\\nreturn parser;'\n        + '\\n});'\n    return out;\n};\n\nlrGeneratorMixin.generateCommonJSModule = function generateCommonJSModule (opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var moduleName = opt.moduleName || \"parser\";\n    var out = this.generateModule(opt)\n        + \"\\n\\n\\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\"\n        + \"\\nexports.parser = \"+moduleName+\";\"\n        + \"\\nexports.Parser = \"+moduleName+\".Parser;\"\n        + \"\\nexports.parse = function () { return \"+moduleName+\".parse.apply(\"+moduleName+\", arguments); };\"\n        + \"\\nexports.main = \"+ String(opt.moduleMain || commonjsMain) + \";\"\n        + \"\\nif (typeof module !== 'undefined' && require.main === module) {\\n\"\n        + \"  exports.main(process.argv.slice(1));\\n}\"\n        + \"\\n}\";\n\n    return out;\n};\n\nlrGeneratorMixin.generateModule = function generateModule (opt) {\n    opt = typal.mix.call({}, this.options, opt);\n    var moduleName = opt.moduleName || \"parser\";\n    var out = \"/* parser generated by jison \" + version + \" */\\n\"\n        + \"/*\\n\"\n        + \"  Returns a Parser object of the following structure:\\n\"\n        + \"\\n\"\n        + \"  Parser: {\\n\"\n        + \"    yy: {}\\n\"\n        + \"  }\\n\"\n        + \"\\n\"\n        + \"  Parser.prototype: {\\n\"\n        + \"    yy: {},\\n\"\n        + \"    trace: function(),\\n\"\n        + \"    symbols_: {associative list: name ==> number},\\n\"\n        + \"    terminals_: {associative list: number ==> name},\\n\"\n        + \"    productions_: [...],\\n\"\n        + \"    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\\n\"\n        + \"    table: [...],\\n\"\n        + \"    defaultActions: {...},\\n\"\n        + \"    parseError: function(str, hash),\\n\"\n        + \"    parse: function(input),\\n\"\n        + \"\\n\"\n        + \"    lexer: {\\n\"\n        + \"        EOF: 1,\\n\"\n        + \"        parseError: function(str, hash),\\n\"\n        + \"        setInput: function(input),\\n\"\n        + \"        input: function(),\\n\"\n        + \"        unput: function(str),\\n\"\n        + \"        more: function(),\\n\"\n        + \"        less: function(n),\\n\"\n        + \"        pastInput: function(),\\n\"\n        + \"        upcomingInput: function(),\\n\"\n        + \"        showPosition: function(),\\n\"\n        + \"        test_match: function(regex_match_array, rule_index),\\n\"\n        + \"        next: function(),\\n\"\n        + \"        lex: function(),\\n\"\n        + \"        begin: function(condition),\\n\"\n        + \"        popState: function(),\\n\"\n        + \"        _currentRules: function(),\\n\"\n        + \"        topState: function(),\\n\"\n        + \"        pushState: function(condition),\\n\"\n        + \"\\n\"\n        + \"        options: {\\n\"\n        + \"            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\\n\"\n        + \"            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\\n\"\n        + \"            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\\n\"\n        + \"        },\\n\"\n        + \"\\n\"\n        + \"        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\\n\"\n        + \"        rules: [...],\\n\"\n        + \"        conditions: {associative list: name ==> set},\\n\"\n        + \"    }\\n\"\n        + \"  }\\n\"\n        + \"\\n\"\n        + \"\\n\"\n        + \"  token location info (@$, _$, etc.): {\\n\"\n        + \"    first_line: n,\\n\"\n        + \"    last_line: n,\\n\"\n        + \"    first_column: n,\\n\"\n        + \"    last_column: n,\\n\"\n        + \"    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\\n\"\n        + \"  }\\n\"\n        + \"\\n\"\n        + \"\\n\"\n        + \"  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\\n\"\n        + \"    text:        (matched text)\\n\"\n        + \"    token:       (the produced terminal token, if any)\\n\"\n        + \"    line:        (yylineno)\\n\"\n        + \"  }\\n\"\n        + \"  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\\n\"\n        + \"    loc:         (yylloc)\\n\"\n        + \"    expected:    (string describing the set of expected tokens)\\n\"\n        + \"    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\\n\"\n        + \"  }\\n\"\n        + \"*/\\n\";\n    out += (moduleName.match(/\\./) ? moduleName : \"var \"+moduleName) +\n            \" = \" + this.generateModuleExpr();\n\n    return out;\n};\n\n\nlrGeneratorMixin.generateModuleExpr = function generateModuleExpr () {\n    var out = '';\n    var module = this.generateModule_();\n\n    out += \"(function(){\\n\";\n    out += module.commonCode;\n    out += \"\\nvar parser = \"+module.moduleCode;\n    out += \"\\n\"+this.moduleInclude;\n    if (this.lexer && this.lexer.generateModule) {\n        out += this.lexer.generateModule();\n        out += \"\\nparser.lexer = lexer;\";\n    }\n    out += \"\\nfunction Parser () {\\n  this.yy = {};\\n}\\n\"\n        + \"Parser.prototype = parser;\"\n        + \"parser.Parser = Parser;\"\n        + \"\\nreturn new Parser;\\n})();\";\n\n    return out;\n};\n\nfunction addTokenStack (fn) {\n    var parseFn = fn;\n    try {\n        var ast = esprima.parse(parseFn);\n        var stackAst = esprima.parse(String(tokenStackLex)).body[0];\n        stackAst.id.name = 'lex';\n\n        var labeled = JSONSelect.match(':has(:root > .label > .name:val(\"_token_stack\"))', ast);\n\n        labeled[0].body = stackAst;\n\n        return escodegen.generate(ast).replace(/_token_stack:\\s?/,\"\").replace(/\\\\\\\\n/g,\"\\\\n\");\n    } catch (e) {\n        return parseFn;\n    }\n}\n\n// lex function that supports token stacks\nfunction tokenStackLex() {\n    var token;\n    token = tstack.pop() || lexer.lex() || EOF;\n    // if token isn't its numeric value, convert\n    if (typeof token !== 'number') {\n        if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n        }\n        token = self.symbols_[token] || token;\n    }\n    return token;\n}\n\n// returns parse function without error recovery code\nfunction removeErrorRecovery (fn) {\n    var parseFn = fn;\n    try {\n        var ast = esprima.parse(parseFn);\n\n        var labeled = JSONSelect.match(':has(:root > .label > .name:val(\"_handle_error\"))', ast);\n        var reduced_code = labeled[0].body.consequent.body[3].consequent.body;\n        reduced_code[0] = labeled[0].body.consequent.body[1];     // remove the line: error_rule_depth = locateNearestErrorRecoveryRule(state);\n        reduced_code[4].expression.arguments[1].properties.pop(); // remove the line: 'recoverable: error_rule_depth !== false'\n        labeled[0].body.consequent.body = reduced_code;\n\n        return escodegen.generate(ast).replace(/_handle_error:\\s?/,\"\").replace(/\\\\\\\\n/g,\"\\\\n\");\n    } catch (e) {\n        return parseFn;\n    }\n}\n\n// Generates the code of the parser module, which consists of two parts:\n// - module.commonCode: initialization code that should be placed before the module\n// - module.moduleCode: code that creates the module object\nlrGeneratorMixin.generateModule_ = function generateModule_ () {\n    var parseFn = String(parser.parse);\n    if (!this.hasErrorRecovery) {\n      parseFn = removeErrorRecovery(parseFn);\n    }\n\n    if (this.options['token-stack']) {\n      parseFn = addTokenStack(parseFn);\n    }\n\n    // Generate code with fresh variable names\n    nextVariableId = 0;\n    var tableCode = this.generateTableCode(this.table);\n\n    // Generate the initialization code\n    var commonCode = tableCode.commonCode;\n\n    // Generate the module creation code\n    var moduleCode = \"{\";\n    moduleCode += [\n        \"trace: \" + String(this.trace || parser.trace),\n        \"yy: {}\",\n        \"symbols_: \" + JSON.stringify(this.symbols_),\n        \"terminals_: \" + JSON.stringify(this.terminals_).replace(/\"([0-9]+)\":/g,\"$1:\"),\n        \"productions_: \" + JSON.stringify(this.productions_),\n        \"performAction: \" + String(this.performAction),\n        \"table: \" + tableCode.moduleCode,\n        \"defaultActions: \" + JSON.stringify(this.defaultActions).replace(/\"([0-9]+)\":/g,\"$1:\"),\n        \"parseError: \" + String(this.parseError || (this.hasErrorRecovery ? traceParseError : parser.parseError)),\n        \"parse: \" + parseFn\n        ].join(\",\\n\");\n    moduleCode += \"};\";\n\n    return { commonCode: commonCode, moduleCode: moduleCode }\n};\n\n// Generate code that represents the specified parser table\nlrGeneratorMixin.generateTableCode = function (table) {\n    var moduleCode = JSON.stringify(table);\n    var variables = [createObjectCode];\n\n    // Don't surround numerical property name numbers in quotes\n    moduleCode = moduleCode.replace(/\"([0-9]+)\"(?=:)/g, \"$1\");\n\n    // Replace objects with several identical values by function calls\n    // e.g., { 1: [6, 7]; 3: [6, 7], 4: [6, 7], 5: 8 } = o([1, 3, 4], [6, 7], { 5: 8 })\n    moduleCode = moduleCode.replace(/\\{\\d+:[^\\}]+,\\d+:[^\\}]+\\}/g, function (object) {\n        // Find the value that occurs with the highest number of keys\n        var value, frequentValue, key, keys = {}, keyCount, maxKeyCount = 0,\n            keyValue, keyValues = [], keyValueMatcher = /(\\d+):([^:]+)(?=,\\d+:|\\})/g;\n\n        while ((keyValue = keyValueMatcher.exec(object))) {\n            // For each value, store the keys where that value occurs\n            key = keyValue[1];\n            value = keyValue[2];\n            keyCount = 1;\n\n            if (!(value in keys)) {\n                keys[value] = [key];\n            } else {\n                keyCount = keys[value].push(key);\n            }\n            // Remember this value if it is the most frequent one\n            if (keyCount > maxKeyCount) {\n                maxKeyCount = keyCount;\n                frequentValue = value;\n            }\n        }\n        // Construct the object with a function call if the most frequent value occurs multiple times\n        if (maxKeyCount > 1) {\n            // Collect all non-frequent values into a remainder object\n            for (value in keys) {\n                if (value !== frequentValue) {\n                    for (var k = keys[value], i = 0, l = k.length; i < l; i++) {\n                        keyValues.push(k[i] + ':' + value);\n                    }\n                }\n            }\n            keyValues = keyValues.length ? ',{' + keyValues.join(',') + '}' : '';\n            // Create the function call `o(keys, value, remainder)`\n            object = 'o([' + keys[frequentValue].join(',') + '],' + frequentValue + keyValues + ')';\n        }\n        return object;\n    });\n\n    // Count occurrences of number lists\n    var list;\n    var lists = {};\n    var listMatcher = /\\[[0-9,]+\\]/g;\n\n    while (list = listMatcher.exec(moduleCode)) {\n        lists[list] = (lists[list] || 0) + 1;\n    }\n\n    // Replace frequently occurring number lists with variables\n    moduleCode = moduleCode.replace(listMatcher, function (list) {\n        var listId = lists[list];\n        // If listId is a number, it represents the list's occurrence frequency\n        if (typeof listId === 'number') {\n            // If the list does not occur frequently, represent it by the list\n            if (listId === 1) {\n                lists[list] = listId = list;\n            // If the list occurs frequently, represent it by a newly assigned variable\n            } else {\n                lists[list] = listId = createVariable();\n                variables.push(listId + '=' + list);\n            }\n        }\n        return listId;\n    });\n\n    // Return the variable initialization code and the table code\n    return {\n        commonCode: 'var ' + variables.join(',') + ';',\n        moduleCode: moduleCode\n    };\n};\n// Function that extends an object with the given value for all given keys\n// e.g., o([1, 3, 4], [6, 7], { x: 1, y: 2 }) = { 1: [6, 7]; 3: [6, 7], 4: [6, 7], x: 1, y: 2 }\nvar createObjectCode = 'o=function(k,v,o,l){' +\n    'for(o=o||{},l=k.length;l--;o[k[l]]=v);' +\n    'return o}';\n\n// Creates a variable with a unique name\nfunction createVariable() {\n    var id = nextVariableId++;\n    var name = '$V';\n\n    do {\n        name += variableTokens[id % variableTokensLength];\n        id = ~~(id / variableTokensLength);\n    } while (id !== 0);\n\n    return name;\n}\n\nvar nextVariableId = 0;\nvar variableTokens = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';\nvar variableTokensLength = variableTokens.length;\n\n// default main method for generated commonjs modules\nfunction commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n}\n\n// debug mixin for LR parser generators\n\nfunction printAction (a, gen) {\n    var s = a[0] == 1 ? 'shift token (then go to state '+a[1]+')' :\n        a[0] == 2 ? 'reduce by rule: '+gen.productions[a[1]] :\n                    'accept' ;\n\n    return s;\n}\n\nvar lrGeneratorDebug = {\n    beforeparseTable: function () {\n        this.trace(\"Building parse table.\");\n    },\n    afterparseTable: function () {\n        var self = this;\n        if (this.conflicts > 0) {\n            this.resolutions.forEach(function (r, i) {\n                if (r[2].bydefault) {\n                    self.warn('Conflict at state: ',r[0], ', token: ',r[1], \"\\n  \", printAction(r[2].r, self), \"\\n  \", printAction(r[2].s, self));\n                }\n            });\n            this.trace(\"\\n\"+this.conflicts+\" Conflict(s) found in grammar.\");\n        }\n        this.trace(\"Done.\");\n    },\n    aftercanonicalCollection: function (states) {\n        var trace = this.trace;\n        trace(\"\\nItem sets\\n------\");\n\n        states.forEach(function (state, i) {\n            trace(\"\\nitem set\",i,\"\\n\"+state.join(\"\\n\"), '\\ntransitions -> ', JSON.stringify(state.edges));\n        });\n    }\n};\n\nvar parser = typal.beget();\n\nlrGeneratorMixin.createParser = function createParser () {\n\n    var p = eval(this.generateModuleExpr());\n\n    // for debugging\n    p.productions = this.productions;\n\n    var self = this;\n    function bind(method) {\n        return function() {\n            self.lexer = p.lexer;\n            return self[method].apply(self, arguments);\n        };\n    }\n\n    // backwards compatability\n    p.lexer = this.lexer;\n    p.generate = bind('generate');\n    p.generateAMDModule = bind('generateAMDModule');\n    p.generateModule = bind('generateModule');\n    p.generateCommonJSModule = bind('generateCommonJSModule');\n\n    return p;\n};\n\nparser.trace = generator.trace;\nparser.warn = generator.warn;\nparser.error = generator.error;\n\nfunction traceParseError (err, hash) {\n    this.trace(err);\n}\n\nfunction parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n}\n\nparser.parseError = lrGeneratorMixin.parseError = parseError;\n\nparser.parse = function parse (input) {\n    var self = this,\n        stack = [0],\n        tstack = [], // token stack\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    var args = lstack.slice.call(arguments, 1);\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    // copy state\n    for (var k in this.yy) {\n      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n        sharedState.yy[k] = this.yy[k];\n      }\n    }\n\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n\n    var ranges = lexer.options && lexer.options.ranges;\n\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n\n    function popStack (n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n_token_stack:\n    var lex = function () {\n        var token;\n        token = lexer.lex() || EOF;\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length - 1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n_handle_error:\n        // handle parse error\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n            var error_rule_depth;\n            var errStr = '';\n\n            // Return the rule stack depth where the nearest error rule can be found.\n            // Return FALSE when no error recovery rule was found.\n            function locateNearestErrorRecoveryRule(state) {\n                var stack_probe = stack.length - 1;\n                var depth = 0;\n\n                // try to recover from error\n                for(;;) {\n                    // check for error recovery rule in this state\n                    if ((TERROR.toString()) in table[state]) {\n                        return depth;\n                    }\n                    if (state === 0 || stack_probe < 2) {\n                        return false; // No suitable error recovery rule available.\n                    }\n                    stack_probe -= 2; // popStack(1): [symbol, action]\n                    state = stack[stack_probe];\n                    ++depth;\n                }\n            }\n\n            if (!recovering) {\n                // first see if there's any chance at hitting an error recovery rule:\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n\n                // Report error\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push(\"'\"+this.terminals_[p]+\"'\");\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol)+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == EOF ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected,\n                    recoverable: (error_rule_depth !== false)\n                });\n            } else if (preErrorSymbol !== EOF) {\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol === EOF || preErrorSymbol === EOF) {\n                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            if (error_rule_depth === false) {\n                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\n            }\n            popStack(error_rule_depth);\n\n            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(lexer.yytext);\n                lstack.push(lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = lexer.yyleng;\n                    yytext = lexer.yytext;\n                    yylineno = lexer.yylineno;\n                    yyloc = lexer.yylloc;\n                    if (recovering > 0) {\n                        recovering--;\n                    }\n                } else {\n                    // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2:\n                // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                if (ranges) {\n                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];\n                }\n                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3:\n                // accept\n                return true;\n        }\n\n    }\n\n    return true;\n};\n\nparser.init = function parser_init (dict) {\n    this.table = dict.table;\n    this.defaultActions = dict.defaultActions;\n    this.performAction = dict.performAction;\n    this.productions_ = dict.productions_;\n    this.symbols_ = dict.symbols_;\n    this.terminals_ = dict.terminals_;\n};\n\n/*\n * LR(0) Parser\n * */\n\nvar lr0 = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    type: \"LR(0)\",\n    afterconstructor: function lr0_afterconstructor () {\n        this.buildTable();\n    }\n});\n\nvar LR0Generator = exports.LR0Generator = lr0.construct();\n\n/*\n * Simple LALR(1)\n * */\n\nvar lalr = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    type: \"LALR(1)\",\n\n    afterconstructor: function (grammar, options) {\n        if (this.DEBUG) this.mix(lrGeneratorDebug, lalrGeneratorDebug); // mixin debug methods\n\n        options = options || {};\n        this.states = this.canonicalCollection();\n        this.terms_ = {};\n\n        var newg = this.newg = typal.beget(lookaheadMixin,{\n            oldg: this,\n            trace: this.trace,\n            nterms_: {},\n            DEBUG: false,\n            go_: function (r, B) {\n                r = r.split(\":\")[0]; // grab state #\n                B = B.map(function (b) { return b.slice(b.indexOf(\":\")+1); });\n                return this.oldg.go(r, B);\n            }\n        });\n        newg.nonterminals = {};\n        newg.productions = [];\n\n        this.inadequateStates = [];\n\n        // if true, only lookaheads in inadequate states are computed (faster, larger table)\n        // if false, lookaheads for all reductions will be computed (slower, smaller table)\n        this.onDemandLookahead = options.onDemandLookahead || false;\n\n        this.buildNewGrammar();\n        newg.computeLookaheads();\n        this.unionLookaheads();\n\n        this.table = this.parseTable(this.states);\n        this.defaultActions = findDefaults(this.table);\n    },\n\n    lookAheads: function LALR_lookaheads (state, item) {\n        return (!!this.onDemandLookahead && !state.inadequate) ? this.terminals : item.follows;\n    },\n    go: function LALR_go (p, w) {\n        var q = parseInt(p, 10);\n        for (var i=0;i<w.length;i++) {\n            q = this.states.item(q).edges[w[i]] || q;\n        }\n        return q;\n    },\n    goPath: function LALR_goPath (p, w) {\n        var q = parseInt(p, 10),t,\n            path = [];\n        for (var i=0;i<w.length;i++) {\n            t = w[i] ? q+\":\"+w[i] : '';\n            if (t) this.newg.nterms_[t] = q;\n            path.push(t);\n            q = this.states.item(q).edges[w[i]] || q;\n            this.terms_[t] = w[i];\n        }\n        return {path: path, endState: q};\n    },\n    // every disjoint reduction of a nonterminal becomes a produciton in G'\n    buildNewGrammar: function LALR_buildNewGrammar () {\n        var self = this,\n            newg = this.newg;\n\n        this.states.forEach(function (state, i) {\n            state.forEach(function (item) {\n                if (item.dotPosition === 0) {\n                    // new symbols are a combination of state and transition symbol\n                    var symbol = i+\":\"+item.production.symbol;\n                    self.terms_[symbol] = item.production.symbol;\n                    newg.nterms_[symbol] = i;\n                    if (!newg.nonterminals[symbol])\n                        newg.nonterminals[symbol] = new Nonterminal(symbol);\n                    var pathInfo = self.goPath(i, item.production.handle);\n                    var p = new Production(symbol, pathInfo.path, newg.productions.length);\n                    newg.productions.push(p);\n                    newg.nonterminals[symbol].productions.push(p);\n\n                    // store the transition that get's 'backed up to' after reduction on path\n                    var handle = item.production.handle.join(' ');\n                    var goes = self.states.item(pathInfo.endState).goes;\n                    if (!goes[handle])\n                        goes[handle] = [];\n                    goes[handle].push(symbol);\n\n                    //self.trace('new production:',p);\n                }\n            });\n            if (state.inadequate)\n                self.inadequateStates.push(i);\n        });\n    },\n    unionLookaheads: function LALR_unionLookaheads () {\n        var self = this,\n            newg = this.newg,\n            states = !!this.onDemandLookahead ? this.inadequateStates : this.states;\n\n        states.forEach(function union_states_forEach (i) {\n            var state = typeof i === 'number' ? self.states.item(i) : i,\n                follows = [];\n            if (state.reductions.length)\n            state.reductions.forEach(function union_reduction_forEach (item) {\n                var follows = {};\n                for (var k=0;k<item.follows.length;k++) {\n                    follows[item.follows[k]] = true;\n                }\n                state.goes[item.production.handle.join(' ')].forEach(function reduction_goes_forEach (symbol) {\n                    newg.nonterminals[symbol].follows.forEach(function goes_follows_forEach (symbol) {\n                        var terminal = self.terms_[symbol];\n                        if (!follows[terminal]) {\n                            follows[terminal]=true;\n                            item.follows.push(terminal);\n                        }\n                    });\n                });\n                //self.trace('unioned item', item);\n            });\n        });\n    }\n});\n\nvar LALRGenerator = exports.LALRGenerator = lalr.construct();\n\n// LALR generator debug mixin\n\nvar lalrGeneratorDebug = {\n    trace: function trace () {\n        Jison.print.apply(null, arguments);\n    },\n    beforebuildNewGrammar: function () {\n        this.trace(this.states.size()+\" states.\");\n        this.trace(\"Building lookahead grammar.\");\n    },\n    beforeunionLookaheads: function () {\n        this.trace(\"Computing lookaheads.\");\n    }\n};\n\n/*\n * Lookahead parser definitions\n *\n * Define base type\n * */\nvar lrLookaheadGenerator = generator.beget(lookaheadMixin, lrGeneratorMixin, {\n    afterconstructor: function lr_aftercontructor () {\n        this.computeLookaheads();\n        this.buildTable();\n    }\n});\n\n/*\n * SLR Parser\n * */\nvar SLRGenerator = exports.SLRGenerator = lrLookaheadGenerator.construct({\n    type: \"SLR(1)\",\n\n    lookAheads: function SLR_lookAhead (state, item) {\n        return this.nonterminals[item.production.symbol].follows;\n    }\n});\n\n\n/*\n * LR(1) Parser\n * */\nvar lr1 = lrLookaheadGenerator.beget({\n    type: \"Canonical LR(1)\",\n\n    lookAheads: function LR_lookAheads (state, item) {\n        return item.follows;\n    },\n    Item: lrGeneratorMixin.Item.prototype.construct({\n        afterconstructor: function () {\n            this.id = this.production.id+'a'+this.dotPosition+'a'+this.follows.sort().join(',');\n        },\n        eq: function (e) {\n            return e.id === this.id;\n        }\n    }),\n\n    closureOperation: function LR_ClosureOperation (itemSet /*, closureSet*/) {\n        var closureSet = new this.ItemSet();\n        var self = this;\n\n        var set = itemSet,\n            itemQueue, syms = {};\n\n        do {\n        itemQueue = new Set();\n        closureSet.concat(set);\n        set.forEach(function (item) {\n            var symbol = item.markedSymbol;\n            var b, r;\n\n            // if token is a nonterminal, recursively add closures\n            if (symbol && self.nonterminals[symbol]) {\n                r = item.remainingHandle();\n                b = self.first(item.remainingHandle());\n                if (b.length === 0 || item.production.nullable || self.nullable(r)) {\n                    b = b.concat(item.follows);\n                }\n                self.nonterminals[symbol].productions.forEach(function (production) {\n                    var newItem = new self.Item(production, 0, b);\n                    if(!closureSet.contains(newItem) && !itemQueue.contains(newItem)) {\n                        itemQueue.push(newItem);\n                    }\n                });\n            } else if (!symbol) {\n                // reduction\n                closureSet.reductions.push(item);\n            }\n        });\n\n        set = itemQueue;\n        } while (!itemQueue.isEmpty());\n\n        return closureSet;\n    }\n});\n\nvar LR1Generator = exports.LR1Generator = lr1.construct();\n\n/*\n * LL Parser\n * */\nvar ll = generator.beget(lookaheadMixin, {\n    type: \"LL(1)\",\n\n    afterconstructor: function ll_aftercontructor () {\n        this.computeLookaheads();\n        this.table = this.parseTable(this.productions);\n    },\n    parseTable: function llParseTable (productions) {\n        var table = {},\n            self = this;\n        productions.forEach(function (production, i) {\n            var row = table[production.symbol] || {};\n            var tokens = production.first;\n            if (self.nullable(production.handle)) {\n                Set.union(tokens, self.nonterminals[production.symbol].follows);\n            }\n            tokens.forEach(function (token) {\n                if (row[token]) {\n                    row[token].push(i);\n                    self.conflicts++;\n                } else {\n                    row[token] = [i];\n                }\n            });\n            table[production.symbol] = row;\n        });\n\n        return table;\n    }\n});\n\nvar LLGenerator = exports.LLGenerator = ll.construct();\n\nJison.Generator = function Jison_Generator (g, options) {\n    var opt = typal.mix.call({}, g.options, options);\n    switch (opt.type) {\n        case 'lr0':\n            return new LR0Generator(g, opt);\n        case 'slr':\n            return new SLRGenerator(g, opt);\n        case 'lr':\n            return new LR1Generator(g, opt);\n        case 'll':\n            return new LLGenerator(g, opt);\n        default:\n            return new LALRGenerator(g, opt);\n    }\n};\n\nreturn function Parser (g, options) {\n        var gen = Jison.Generator(g, options);\n        return gen.createParser();\n    };\n\n})();\n","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison/lib/util/typal.js":"/*\n * Introduces a typal object to make classical/prototypal patterns easier\n * Plus some AOP sugar\n *\n * By Zachary Carter <zach@carter.name>\n * MIT Licensed\n * */\n\nvar typal = (function () {\n\nvar create = Object.create || function (o) { function F(){} F.prototype = o; return new F(); };\nvar position = /^(before|after)/;\n\n// basic method layering\n// always returns original method's return value\nfunction layerMethod(k, fun) {\n    var pos = k.match(position)[0],\n        key = k.replace(position, ''),\n        prop = this[key];\n\n    if (pos === 'after') {\n        this[key] = function () {\n            var ret = prop.apply(this, arguments);\n            var args = [].slice.call(arguments);\n            args.splice(0, 0, ret);\n            fun.apply(this, args);\n            return ret;\n        };\n    } else if (pos === 'before') {\n        this[key] = function () {\n            fun.apply(this, arguments);\n            var ret = prop.apply(this, arguments);\n            return ret;\n        };\n    }\n}\n\n// mixes each argument's own properties into calling object,\n// overwriting them or layering them. i.e. an object method 'meth' is\n// layered by mixin methods 'beforemeth' or 'aftermeth'\nfunction typal_mix() {\n    var self = this;\n    for(var i=0,o,k; i<arguments.length; i++) {\n        o=arguments[i];\n        if (!o) continue;\n        if (Object.prototype.hasOwnProperty.call(o,'constructor'))\n            this.constructor = o.constructor;\n        if (Object.prototype.hasOwnProperty.call(o,'toString'))\n            this.toString = o.toString;\n        for(k in o) {\n            if (Object.prototype.hasOwnProperty.call(o, k)) {\n                if(k.match(position) && typeof this[k.replace(position, '')] === 'function')\n                    layerMethod.call(this, k, o[k]);\n                else\n                    this[k] = o[k];\n            }\n        }\n    }\n    return this;\n}\n\nreturn {\n    // extend object with own typalperties of each argument\n    mix: typal_mix,\n\n    // sugar for object begetting and mixing\n    // - Object.create(typal).mix(etc, etc);\n    // + typal.beget(etc, etc);\n    beget: function typal_beget() {\n        return arguments.length ? typal_mix.apply(create(this), arguments) : create(this);\n    },\n\n    // Creates a new Class function based on an object with a constructor method\n    construct: function typal_construct() {\n        var o = typal_mix.apply(create(this), arguments);\n        var constructor = o.constructor;\n        var Klass = o.constructor = function () { return constructor.apply(this, arguments); };\n        Klass.prototype = o;\n        Klass.mix = typal_mix; // allow for easy singleton property extension\n        return Klass;\n    },\n\n    // no op\n    constructor: function typal_constructor() { return this; }\n};\n\n})();\n\nif (typeof exports !== 'undefined')\n    exports.typal = typal;\n","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison/lib/util/set.js":"// Set class to wrap arrays\n\nvar typal = require(\"./typal\").typal;\n\nvar setMixin = {\n    constructor: function Set_constructor (set, raw) {\n        this._items = [];\n        if (set && set.constructor === Array)\n            this._items = raw ? set: set.slice(0);\n        else if(arguments.length)\n            this._items = [].slice.call(arguments,0);\n    },\n    concat: function concat (setB) {\n        this._items.push.apply(this._items, setB._items || setB); \n        return this;\n    },\n    eq: function eq (set) {\n        return this._items.length === set._items.length && this.subset(set); \n    },\n    indexOf: function indexOf (item) {\n        if(item && item.eq) {\n            for(var k=0; k<this._items.length;k++)\n                if(item.eq(this._items[k]))\n                    return k;\n            return -1;\n        }\n        return this._items.indexOf(item);\n    },\n    union: function union (set) {\n        return (new Set(this._items)).concat(this.complement(set));\n    },\n    intersection: function intersection (set) {\n    return this.filter(function (elm) {\n            return set.contains(elm);\n        });\n    },\n    complement: function complement (set) {\n        var that = this;\n        return set.filter(function sub_complement (elm) {\n            return !that.contains(elm);\n        });\n    },\n    subset: function subset (set) {\n        var cont = true;\n        for (var i=0; i<this._items.length && cont;i++) {\n            cont = cont && set.contains(this._items[i]);\n        }\n        return cont;\n    },\n    superset: function superset (set) {\n        return set.subset(this);\n    },\n    joinSet: function joinSet (set) {\n        return this.concat(this.complement(set));\n    },\n    contains: function contains (item) { return this.indexOf(item) !== -1; },\n    item: function item (v, val) { return this._items[v]; },\n    i: function i (v, val) { return this._items[v]; },\n    first: function first () { return this._items[0]; },\n    last: function last () { return this._items[this._items.length-1]; },\n    size: function size () { return this._items.length; },\n    isEmpty: function isEmpty () { return this._items.length === 0; },\n    copy: function copy () { return new Set(this._items); },\n    toString: function toString () { return this._items.toString(); }\n};\n\n\"push shift unshift forEach some every join sort\".split(' ').forEach(function (e,i) {\n    setMixin[e] = function () { return Array.prototype[e].apply(this._items, arguments); };\n    setMixin[e].name = e;\n});\n\"filter slice map\".split(' ').forEach(function (e,i) {\n    setMixin[e] = function () { return new Set(Array.prototype[e].apply(this._items, arguments), true); };\n    setMixin[e].name = e;\n});\n\nvar Set = typal.construct(setMixin).mix({\n    union: function (a, b) {\n        var ar = {};\n        for (var k=a.length-1;k >=0;--k) {\n            ar[a[k]] = true;\n        }\n        for (var i=b.length-1;i >= 0;--i) {\n            if (!ar[b[i]]) {\n                a.push(b[i]);\n            }\n        }\n        return a;\n    }\n});\n\nif (typeof exports !== 'undefined')\n    exports.Set = Set;\n\n","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison-lex/regexp-lexer.js":"// Basic Lexer implemented using JavaScript regular expressions\n// MIT Licensed\n\n\"use strict\";\n\nvar lexParser = require('lex-parser');\nvar version = require('./package.json').version;\n\n// expand macros and convert matchers to RegExp's\nfunction prepareRules(rules, macros, actions, tokens, startConditions, caseless) {\n    var m,i,k,action,conditions,\n        newRules = [];\n\n    if (macros) {\n        macros = prepareMacros(macros);\n    }\n\n    function tokenNumberReplacement (str, token) {\n        return \"return \" + (tokens[token] || \"'\" + token + \"'\");\n    }\n\n    actions.push('switch($avoiding_name_collisions) {');\n\n    for (i=0;i < rules.length; i++) {\n        if (Object.prototype.toString.apply(rules[i][0]) !== '[object Array]') {\n            // implicit add to all inclusive start conditions\n            for (k in startConditions) {\n                if (startConditions[k].inclusive) {\n                    startConditions[k].rules.push(i);\n                }\n            }\n        } else if (rules[i][0][0] === '*') {\n            // Add to ALL start conditions\n            for (k in startConditions) {\n                startConditions[k].rules.push(i);\n            }\n            rules[i].shift();\n        } else {\n            // Add to explicit start conditions\n            conditions = rules[i].shift();\n            for (k=0;k<conditions.length;k++) {\n                startConditions[conditions[k]].rules.push(i);\n            }\n        }\n\n        m = rules[i][0];\n        if (typeof m === 'string') {\n            for (k in macros) {\n                if (macros.hasOwnProperty(k)) {\n                    m = m.split(\"{\" + k + \"}\").join('(' + macros[k] + ')');\n                }\n            }\n            m = new RegExp(\"^(?:\" + m + \")\", caseless ? 'i':'');\n        }\n        newRules.push(m);\n        if (typeof rules[i][1] === 'function') {\n            rules[i][1] = String(rules[i][1]).replace(/^\\s*function \\(\\)\\s?\\{/, '').replace(/\\}\\s*$/, '');\n        }\n        action = rules[i][1];\n        if (tokens && action.match(/return '[^']+'/)) {\n            action = action.replace(/return '([^']+)'/g, tokenNumberReplacement);\n        }\n        actions.push('case ' + i + ':' + action + '\\nbreak;');\n    }\n    actions.push(\"}\");\n\n    return newRules;\n}\n\n// expand macros within macros\nfunction prepareMacros (macros) {\n    var cont = true,\n        m,i,k,mnew;\n    while (cont) {\n        cont = false;\n        for (i in macros) if (macros.hasOwnProperty(i)) {\n            m = macros[i];\n            for (k in macros) if (macros.hasOwnProperty(k) && i !== k) {\n                mnew = m.split(\"{\" + k + \"}\").join('(' + macros[k] + ')');\n                if (mnew !== m) {\n                    cont = true;\n                    macros[i] = mnew;\n                }\n            }\n        }\n    }\n    return macros;\n}\n\nfunction prepareStartConditions (conditions) {\n    var sc,\n        hash = {};\n    for (sc in conditions) if (conditions.hasOwnProperty(sc)) {\n        hash[sc] = {rules:[],inclusive:!!!conditions[sc]};\n    }\n    return hash;\n}\n\nfunction buildActions (dict, tokens) {\n    var actions = [dict.actionInclude || '', \"var YYSTATE=YY_START;\"];\n    var tok;\n    var toks = {};\n\n    for (tok in tokens) {\n        toks[tokens[tok]] = tok;\n    }\n\n    if (dict.options && dict.options.flex) {\n        dict.rules.push([\".\", \"console.log(yytext);\"]);\n    }\n\n    this.rules = prepareRules(dict.rules, dict.macros, actions, tokens && toks, this.conditions, this.options[\"case-insensitive\"]);\n    var fun = actions.join(\"\\n\");\n    \"yytext yyleng yylineno yylloc\".split(' ').forEach(function (yy) {\n        fun = fun.replace(new RegExp(\"\\\\b(\" + yy + \")\\\\b\", \"g\"), \"yy_.$1\");\n    });\n\n    return \"function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\" + fun + \"\\n}\";\n}\n\nfunction RegExpLexer (dict, input, tokens) {\n    var opts = processGrammar(dict, tokens);\n    var source = generateModuleBody(opts);\n    var lexer = eval(source);\n\n    lexer.yy = {};\n    if (input) {\n        lexer.setInput(input);\n    }\n\n    lexer.generate = function () { return generateFromOpts(opts); };\n    lexer.generateModule = function () { return generateModule(opts); };\n    lexer.generateCommonJSModule = function () { return generateCommonJSModule(opts); };\n    lexer.generateAMDModule = function () { return generateAMDModule(opts); };\n\n    return lexer;\n}\n\nRegExpLexer.prototype = {\n    EOF: 1,\n    parseError: function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n    // resets the lexer, sets new input\n    setInput: function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n    // consumes and returns one char from the input\n    input: function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n    // unshifts one char (or a string) into the input\n    unput: function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n    // When called from action, caches matched text and appends it on next action\n    more: function () {\n        this._more = true;\n        return this;\n    },\n\n    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n    reject: function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n    // retain first n characters of the match\n    less: function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n    // displays already matched input, i.e. for error messages\n    pastInput: function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n    // displays upcoming input, i.e. for error messages\n    upcomingInput: function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n    // displays the character position where the lexing error occurred, i.e. for error messages\n    showPosition: function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n    // test the lexed token: return FALSE when not a match, otherwise return token\n    test_match: function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n    // return next match in input\n    next: function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n    // return next match that has a token\n    lex: function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n    begin: function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n    // pop the previously active lexer condition state off the condition stack\n    popState: function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n    // produce the lexer rule set which is active for the currently active lexer condition state\n    _currentRules: function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n    topState: function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n    // alias for begin(condition)\n    pushState: function pushState (condition) {\n        this.begin(condition);\n    },\n\n    // return the number of states pushed\n    stateStackSize: function stateStackSize() {\n        return this.conditionStack.length;\n    }\n};\n\n\n// generate lexer source from a grammar\nfunction generate (dict, tokens) {\n    var opt = processGrammar(dict, tokens);\n\n    return generateFromOpts(opt);\n}\n\n// process the grammar and build final data structures and functions\nfunction processGrammar(dict, tokens) {\n    var opts = {};\n    if (typeof dict === 'string') {\n        dict = lexParser.parse(dict);\n    }\n    dict = dict || {};\n\n    opts.options = dict.options || {};\n    opts.moduleType = opts.options.moduleType;\n    opts.moduleName = opts.options.moduleName;\n\n    opts.conditions = prepareStartConditions(dict.startConditions);\n    opts.conditions.INITIAL = {rules:[],inclusive:true};\n\n    opts.performAction = buildActions.call(opts, dict, tokens);\n    opts.conditionStack = ['INITIAL'];\n\n    opts.moduleInclude = (dict.moduleInclude || '').trim();\n    return opts;\n}\n\n// Assemble the final source from the processed grammar\nfunction generateFromOpts (opt) {\n    var code = \"\";\n\n    if (opt.moduleType === 'commonjs') {\n        code = generateCommonJSModule(opt);\n    } else if (opt.moduleType === 'amd') {\n        code = generateAMDModule(opt);\n    } else {\n        code = generateModule(opt);\n    }\n\n    return code;\n}\n\nfunction generateModuleBody (opt) {\n    var functionDescriptions = {\n        setInput: \"resets the lexer, sets new input\",\n        input: \"consumes and returns one char from the input\",\n        unput: \"unshifts one char (or a string) into the input\",\n        more: \"When called from action, caches matched text and appends it on next action\",\n        reject: \"When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\",\n        less: \"retain first n characters of the match\",\n        pastInput: \"displays already matched input, i.e. for error messages\",\n        upcomingInput: \"displays upcoming input, i.e. for error messages\",\n        showPosition: \"displays the character position where the lexing error occurred, i.e. for error messages\",\n        test_match: \"test the lexed token: return FALSE when not a match, otherwise return token\",\n        next: \"return next match in input\",\n        lex: \"return next match that has a token\",\n        begin: \"activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\",\n        popState: \"pop the previously active lexer condition state off the condition stack\",\n        _currentRules: \"produce the lexer rule set which is active for the currently active lexer condition state\",\n        topState: \"return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\",\n        pushState: \"alias for begin(condition)\",\n        stateStackSize: \"return the number of states currently on the stack\"\n    };\n    var out = \"({\\n\";\n    var p = [];\n    var descr;\n    for (var k in RegExpLexer.prototype) {\n        if (RegExpLexer.prototype.hasOwnProperty(k) && k.indexOf(\"generate\") === -1) {\n            // copy the function description as a comment before the implementation; supports multi-line descriptions\n            descr = \"\\n\";\n            if (functionDescriptions[k]) {\n                descr += \"// \" + functionDescriptions[k].replace(/\\n/g, \"\\n\\/\\/ \") + \"\\n\";\n            }\n            p.push(descr + k + \":\" + (RegExpLexer.prototype[k].toString() || '\"\"'));\n        }\n    }\n    out += p.join(\",\\n\");\n\n    if (opt.options) {\n        out += \",\\noptions: \" + JSON.stringify(opt.options);\n    }\n\n    out += \",\\nperformAction: \" + String(opt.performAction);\n    out += \",\\nrules: [\" + opt.rules + \"]\";\n    out += \",\\nconditions: \" + JSON.stringify(opt.conditions);\n    out += \"\\n})\";\n\n    return out;\n}\n\nfunction generateModule(opt) {\n    opt = opt || {};\n\n    var out = \"/* generated by jison-lex \" + version + \" */\";\n    var moduleName = opt.moduleName || \"lexer\";\n\n    out += \"\\nvar \" + moduleName + \" = (function(){\\nvar lexer = \"\n          + generateModuleBody(opt);\n\n    if (opt.moduleInclude) {\n        out += \";\\n\" + opt.moduleInclude;\n    }\n\n    out += \";\\nreturn lexer;\\n})();\";\n\n    return out;\n}\n\nfunction generateAMDModule(opt) {\n    var out = \"/* generated by jison-lex \" + version + \" */\";\n\n    out += \"define([], function(){\\nvar lexer = \"\n          + generateModuleBody(opt);\n\n    if (opt.moduleInclude) {\n        out += \";\\n\" + opt.moduleInclude;\n    }\n\n    out += \";\\nreturn lexer;\"\n         + \"\\n});\";\n\n    return out;\n}\n\nfunction generateCommonJSModule(opt) {\n    opt = opt || {};\n\n    var out = \"\";\n    var moduleName = opt.moduleName || \"lexer\";\n\n    out += generateModule(opt);\n    out += \"\\nexports.lexer = \" + moduleName;\n    out += \";\\nexports.lex = function () { return \" + moduleName + \".lex.apply(lexer, arguments); };\";\n    return out;\n}\n\nRegExpLexer.generate = generate;\n\nmodule.exports = RegExpLexer;\n\n","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison/classy.js":"/* parser generated by jison 0.4.15 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,3],$V1=[1,4],$V2=[1,8],$V3=[19,22,24,25,26,27,28,30,31,32,38],$V4=[2,6],$V5=[1,12],$V6=[1,26],$V7=[1,16],$V8=[1,17],$V9=[1,19],$Va=[1,20],$Vb=[1,21],$Vc=[1,22],$Vd=[1,23],$Ve=[1,24],$Vf=[1,25],$Vg=[1,28],$Vh=[1,33],$Vi=[1,34],$Vj=[1,35],$Vk=[1,36],$Vl=[1,37],$Vm=[1,38],$Vn=[1,39],$Vo=[18,20,33,34,35,36,37,39,40],$Vp=[18,20,33,34,35,36,37,39],$Vq=[2,8],$Vr=[18,20,33,34,36,37,39],$Vs=[18,20,39],$Vt=[9,19,21,22,24,25,26,27,28,30,31,32,38];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"pgm\":3,\"cdl\":4,\"MAIN\":5,\"LBRACE\":6,\"vdl\":7,\"el\":8,\"RBRACE\":9,\"ENDOFFILE\":10,\"c\":11,\"CLASS\":12,\"id\":13,\"EXTENDS\":14,\"mdl\":15,\"VAR\":16,\"t\":17,\"SEMICOLON\":18,\"LPAREN\":19,\"RPAREN\":20,\"NATTYPE\":21,\"ID\":22,\"e\":23,\"NATLITERAL\":24,\"NUL\":25,\"NEW\":26,\"THIS\":27,\"IF\":28,\"ELSE\":29,\"FOR\":30,\"READNAT\":31,\"PRINTNAT\":32,\"PLUS\":33,\"MINUS\":34,\"TIMES\":35,\"EQUALITY\":36,\"GREATER\":37,\"NOT\":38,\"OR\":39,\"DOT\":40,\"ASSIGN\":41,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"MAIN\",6:\"LBRACE\",9:\"RBRACE\",10:\"ENDOFFILE\",12:\"CLASS\",14:\"EXTENDS\",16:\"VAR\",18:\"SEMICOLON\",19:\"LPAREN\",20:\"RPAREN\",21:\"NATTYPE\",22:\"ID\",24:\"NATLITERAL\",25:\"NUL\",26:\"NEW\",27:\"THIS\",28:\"IF\",29:\"ELSE\",30:\"FOR\",31:\"READNAT\",32:\"PRINTNAT\",33:\"PLUS\",34:\"MINUS\",35:\"TIMES\",36:\"EQUALITY\",37:\"GREATER\",38:\"NOT\",39:\"OR\",40:\"DOT\",41:\"ASSIGN\"},\nproductions_: [0,[3,7],[4,2],[4,0],[11,8],[7,5],[7,0],[15,11],[15,0],[17,1],[17,1],[13,1],[8,3],[8,2],[23,1],[23,1],[23,1],[23,2],[23,1],[23,11],[23,11],[23,3],[23,4],[23,3],[23,3],[23,3],[23,3],[23,3],[23,2],[23,3],[23,3],[23,3],[23,5],[23,4],[23,6],[23,3]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\n}\n},\ntable: [{3:1,4:2,5:$V0,11:3,12:$V1},{1:[3]},{5:[1,5]},{4:6,5:$V0,11:3,12:$V1},{13:7,22:$V2},{6:[1,9]},{5:[2,2]},{14:[1,10]},o([6,14,18,19,20,22,33,34,35,36,37,39,40,41],[2,11]),o($V3,$V4,{7:11,16:$V5}),{13:13,22:$V2},{8:14,13:18,19:$V6,22:$V2,23:15,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:29,17:27,21:$Vg,22:$V2},{6:[1,30]},{9:[1,31]},{18:[1,32],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},o($Vo,[2,14]),o($Vo,[2,15]),o($Vo,[2,16],{19:[1,41],41:[1,40]}),{13:42,22:$V2},o($Vo,[2,18]),{19:[1,43]},{19:[1,44]},{19:[1,45]},{19:[1,46]},{13:18,19:$V6,22:$V2,23:47,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:48,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:49,22:$V2},{22:[2,9]},{22:[2,10]},o([9,21,22],$V4,{7:50,16:$V5}),{10:[1,51]},{8:52,9:[2,13],13:18,19:$V6,22:$V2,23:15,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:53,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:54,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:55,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:56,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:57,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:58,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:59,22:$V2},{13:18,19:$V6,22:$V2,23:60,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:61,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},o($Vo,[2,17]),{13:18,19:$V6,22:$V2,23:62,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:63,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{20:[1,64]},{13:18,19:$V6,22:$V2,23:65,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},o($Vp,[2,28],{40:$Vn}),{20:[1,66],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},{18:[1,67]},{9:$Vq,13:29,15:68,17:69,21:$Vg,22:$V2},{1:[2,1]},{9:[2,12]},o($Vr,[2,23],{35:$Vj,40:$Vn}),o($Vr,[2,24],{35:$Vj,40:$Vn}),o($Vp,[2,25],{40:$Vn}),o($Vs,[2,26],{33:$Vh,34:$Vi,35:$Vj,40:$Vn}),o($Vs,[2,27],{33:$Vh,34:$Vi,35:$Vj,40:$Vn}),o($Vs,[2,29],{33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,40:$Vn}),o($Vo,[2,30],{19:[1,71],41:[1,70]}),o([18,20],[2,31],{33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn}),{20:[1,72],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},{20:[1,73],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},{18:[1,74],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},o($Vo,[2,21]),{20:[1,75],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},o($Vo,[2,35]),o($Vt,$V4,{7:76,16:$V5}),{9:[1,77]},{13:78,22:$V2},{13:18,19:$V6,22:$V2,23:79,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:18,19:$V6,22:$V2,23:80,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},o($Vo,[2,33]),{6:[1,81]},{13:18,19:$V6,22:$V2,23:82,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},o($Vo,[2,22]),o($Vt,[2,5]),o([5,12],[2,4]),{19:[1,83]},o($Vo,[2,32]),{20:[1,84],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},{8:85,13:18,19:$V6,22:$V2,23:15,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{18:[1,86],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},{13:29,17:87,21:$Vg,22:$V2},o($Vo,[2,34]),{9:[1,88]},{13:18,19:$V6,22:$V2,23:89,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{13:90,22:$V2},{29:[1,91]},{20:[1,92],33:$Vh,34:$Vi,35:$Vj,36:$Vk,37:$Vl,39:$Vm,40:$Vn},{20:[1,93]},{6:[1,94]},{6:[1,95]},{6:[1,96]},{8:97,13:18,19:$V6,22:$V2,23:15,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},{8:98,13:18,19:$V6,22:$V2,23:15,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},o($V3,$V4,{7:99,16:$V5}),{9:[1,100]},{9:[1,101]},{8:102,13:18,19:$V6,22:$V2,23:15,24:$V7,25:$V8,26:$V9,27:$Va,28:$Vb,30:$Vc,31:$Vd,32:$Ve,38:$Vf},o($Vo,[2,19]),o($Vo,[2,20]),{9:[1,103]},{9:$Vq,13:29,15:104,17:69,21:$Vg,22:$V2},{9:[2,7]}],\ndefaultActions: {6:[2,2],28:[2,9],29:[2,10],51:[2,1],52:[2,12],104:[2,7]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        function lex() {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison/entry.js":"\nJison = require('./lib/jison.js');\nbnf = require('ebnf-parser');\n","/home/travis/build/npmtest/node-npmtest-jison/node_modules/jison/lib/cli.js":"#!/usr/bin/env node\n\nfunction getCommandlineOptions () {\n    \"use strict\";\n    var version = require('../package.json').version;\n    var opts = require(\"nomnom\")\n        .script('jison')\n        .option('file', {\n            flag : true,\n            position : 0,\n            help : 'file containing a grammar'\n        })\n        .option('lexfile', {\n            flag : true,\n            position : 1,\n            help : 'file containing a lexical grammar'\n        })\n        .option('json', {\n            abbr : 'j',\n            flag : true,\n            help : 'force jison to expect a grammar in JSON format'\n        })\n        .option('outfile', {\n            abbr : 'o',\n            metavar : 'FILE',\n            help : 'Filename and base module name of the generated parser'\n        })\n        .option('debug', {\n            abbr : 't',\n            flag : true,\n        default:\n            false,\n            help : 'Debug mode'\n        })\n        .option('module-type', {\n            abbr : 'm',\n        default:\n            'commonjs',\n            metavar : 'TYPE',\n            help : 'The type of module to generate (commonjs, amd, js)'\n        })\n        .option('parser-type', {\n            abbr : 'p',\n        default:\n            'lalr',\n            metavar : 'TYPE',\n            help : 'The type of algorithm to use for the parser (lr0, slr,' +\n                'lalr, lr)'\n        })\n        .option('version', {\n            abbr : 'V',\n            flag : true,\n            help : 'print version and exit',\n            callback : function () {\n                return version;\n            }\n        }).parse();\n\n    return opts;\n}\n\nvar cli = module.exports;\n\ncli.main = function cliMain(opts) {\n    \"use strict\";\n    opts = opts || {};\n\n    function processGrammar(raw, lex, opts) {\n        var grammar,\n        parser;\n        grammar = cli.processGrammars(raw, lex, opts.json);\n        parser = cli.generateParserString(opts, grammar);\n        return parser;\n    }\n\n    function processInputFile () {\n        var fs = require('fs');\n        var path = require('path');\n\n        // getting raw files\n        var lex;\n        if (opts.lexfile) {\n            lex = fs.readFileSync(path.normalize(opts.lexfile), 'utf8');\n        }\n        var raw = fs.readFileSync(path.normalize(opts.file), 'utf8');\n\n        // making best guess at json mode\n        opts.json = path.extname(opts.file) === '.json' || opts.json;\n\n        // setting output file name and module name based on input file name\n        // if they aren't specified.\n        var name = path.basename((opts.outfile || opts.file));\n\n        name = name.replace(/\\..*$/g, '');\n\n        opts.outfile = opts.outfile || (name + '.js');\n        if (!opts.moduleName && name) {\n            opts.moduleName = name.replace(/-\\w/g,\n                    function (match) {\n                    return match.charAt(1).toUpperCase();\n                });\n        }\n\n        var parser = processGrammar(raw, lex, opts);\n        fs.writeFileSync(opts.outfile, parser);\n    }\n\n    function readin(cb) {\n        var stdin = process.openStdin(),\n        data = '';\n\n        stdin.setEncoding('utf8');\n        stdin.addListener('data', function (chunk) {\n            data += chunk;\n        });\n        stdin.addListener('end', function () {\n            cb(data);\n        });\n    }\n\n    function processStdin () {\n        readin(function (raw) {\n            console.log(processGrammar(raw, null, opts));\n        });\n    }\n\n    // if an input file wasn't given, assume input on stdin\n    if (opts.file) {\n        processInputFile();\n    } else {\n        processStdin();\n    }\n};\n\ncli.generateParserString = function generateParserString(opts, grammar) {\n    \"use strict\";\n    opts = opts || {};\n    var jison = require('./jison.js');\n\n    var settings = grammar.options || {};\n\n    if (opts['parser-type']) {\n        settings.type = opts['parser-type'];\n    }\n    if (opts.moduleName) {\n        settings.moduleName = opts.moduleName;\n    }\n    settings.debug = opts.debug;\n    if (!settings.moduleType) {\n        settings.moduleType = opts['module-type'];\n    }\n\n    var generator = new jison.Generator(grammar, settings);\n    return generator.generate(settings);\n};\n\ncli.processGrammars = function processGrammars(file, lexFile, jsonMode) {\n    \"use strict\";\n    lexFile = lexFile || false;\n    jsonMode = jsonMode || false;\n    var ebnfParser = require('ebnf-parser');\n    var cjson = require('cjson');\n    var grammar;\n    try {\n        if (jsonMode) {\n            grammar = cjson.parse(file);\n        } else {\n            grammar = ebnfParser.parse(file);\n        }\n    } catch (e) {\n        throw new Error('Could not parse jison grammar');\n    }\n    try {\n        if (lexFile) {\n            grammar.lex = require('lex-parser').parse(lexFile);\n        }\n    } catch (e) {\n        throw new Error('Could not parse lex grammar');\n    }\n    return grammar;\n};\n\n\nif (require.main === module) {\n    var opts = getCommandlineOptions();\n    cli.main(opts);\n}\n"}